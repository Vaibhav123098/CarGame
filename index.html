<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pro Hand Steering Car Game</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #222; font-family: 'Segoe UI', sans-serif; }
        
        /* Dashboard UI */
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        #webcam-container {
            position: absolute;
            top: 20px; left: 20px;
            border: 4px solid #444;
            border-radius: 12px;
            overflow: hidden;
            width: 240px; height: 180px;
            background: black;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            z-index: 10;
        }

        #webcam {
            width: 100%; height: 100%;
            transform: scaleX(-1); /* Mirror effect */
            object-fit: cover;
        }

        #dashboard {
            position: absolute;
            bottom: 20px; left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(90deg, rgba(0,0,0,0.8), rgba(20,20,20,0.9));
            padding: 15px 40px;
            border-radius: 50px;
            border: 2px solid #555;
            text-align: center;
            color: #00ffcc;
            font-size: 24px;
            font-weight: bold;
            box-shadow: 0 0 15px rgba(0, 255, 204, 0.2);
        }

        #status-msg { font-size: 16px; color: #aaa; margin-top: 5px; }

        .loading {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: white; font-size: 24px;
            background: rgba(0,0,0,0.9); padding: 30px;
            border-radius: 15px; text-align: center;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="webcam-container">
            <video id="webcam" autoplay playsinline></video>
        </div>
        <div id="dashboard">
            <div id="speed-meter">0 km/h</div>
            <div id="status-msg">Loading AI...</div>
        </div>
    </div>

    <div id="loading-msg" class="loading">
        Initializing 3D Engine & AI...<br>
        <span style="font-size:16px; color:#ccc">Please allow camera access.</span>
    </div>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
        import { FilesetResolver, HandLandmarker } from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0';

        // --- GAME VARIABLES ---
        let scene, camera, renderer;
        let carContainer, carBody, wheelFL, wheelFR, wheelBL, wheelBR;
        let speed = 0;
        let maxSpeed = 0.35; // Slower, more realistic
        let steeringAngle = 0;
        let carRotation = 0;
        
        // --- SETUP THREE.JS ---
        function initThreeJS() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xa0a0a0);
            scene.fog = new THREE.Fog(0xa0a0a0, 20, 80);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // Lights
            const hemiLight = new THREE.HemiLight(0xffffff, 0x444444);
            hemiLight.position.set(0, 20, 0);
            scene.add(hemiLight);

            const dirLight = new THREE.DirectionalLight(0xffffff);
            dirLight.position.set(-10, 20, 10); // Sun position
            dirLight.castShadow = true;
            dirLight.shadow.camera.top = 20;
            dirLight.shadow.camera.bottom = -20;
            dirLight.shadow.camera.left = -20;
            dirLight.shadow.camera.right = 20;
            scene.add(dirLight);

            // Ground
            const mesh = new THREE.Mesh(
                new THREE.PlaneGeometry(500, 500),
                new THREE.MeshPhongMaterial({ color: 0x333333, depthWrite: false })
            );
            mesh.rotation.x = - Math.PI / 2;
            mesh.receiveShadow = true;
            scene.add(mesh);

            // Grid
            const grid = new THREE.GridHelper(500, 100, 0x000000, 0x555555);
            grid.material.opacity = 0.2;
            grid.material.transparent = true;
            scene.add(grid);

            createCar();
            createMapElements();
        }

        function createCar() {
            carContainer = new THREE.Group();

            // 1. Car Body (Red Sporty Shape)
            const bodyGeo = new THREE.BoxGeometry(1.2, 0.5, 2.5);
            const bodyMat = new THREE.MeshPhongMaterial({ color: 0xff2222 });
            carBody = new THREE.Mesh(bodyGeo, bodyMat);
            carBody.position.y = 0.5;
            carBody.castShadow = true;
            carContainer.add(carBody);

            // Cabin (Top)
            const cabinGeo = new THREE.BoxGeometry(1, 0.4, 1.2);
            const cabinMat = new THREE.MeshPhongMaterial({ color: 0x222222 }); // Dark windows
            const cabin = new THREE.Mesh(cabinGeo, cabinMat);
            cabin.position.set(0, 0.9, -0.2);
            carContainer.add(cabin);

            // 2. Wheels Function
            function makeWheel() {
                const geometry = new THREE.CylinderGeometry(0.35, 0.35, 0.3, 32);
                const material = new THREE.MeshPhongMaterial({ color: 0x111111 });
                const wheel = new THREE.Mesh(geometry, material);
                wheel.rotation.z = Math.PI / 2; // Rotate to stand up
                wheel.castShadow = true;
                return wheel;
            }

            // Create 4 Wheels
            // Note: We put wheels inside "Pivot" groups for steering rotation
            
            // Front Left
            wheelFL = makeWheel();
            const pivotFL = new THREE.Group();
            pivotFL.position.set(-0.7, 0.35, -0.9);
            pivotFL.add(wheelFL);
            carContainer.add(pivotFL);
            wheelFL.parentGroup = pivotFL; // Reference for steering

            // Front Right
            wheelFR = makeWheel();
            const pivotFR = new THREE.Group();
            pivotFR.position.set(0.7, 0.35, -0.9);
            pivotFR.add(wheelFR);
            carContainer.add(pivotFR);
            wheelFR.parentGroup = pivotFR;

            // Back Wheels (Fixed)
            wheelBL = makeWheel();
            wheelBL.position.set(-0.7, 0.35, 0.9);
            carContainer.add(wheelBL);

            wheelBR = makeWheel();
            wheelBR.position.set(0.7, 0.35, 0.9);
            carContainer.add(wheelBR);

            scene.add(carContainer);
        }

        function createMapElements() {
            const geometry = new THREE.BoxGeometry(2, 6, 2);
            const material = new THREE.MeshPhongMaterial({ color: 0x445566 });
            
            // Random blocks
            for(let i=0; i<30; i++) {
                const block = new THREE.Mesh(geometry, material);
                block.position.x = (Math.random() - 0.5) * 100;
                block.position.z = (Math.random() - 0.5) * 100;
                
                // Don't spawn on top of car
                if(Math.abs(block.position.x) < 5 && Math.abs(block.position.z) < 5) continue;
                
                block.position.y = 3;
                block.castShadow = true;
                block.receiveShadow = true;
                scene.add(block);
            }
        }

        // --- HAND TRACKING SETUP ---
        let handLandmarker;
        const video = document.getElementById('webcam');
        const statusMsg = document.getElementById('status-msg');
        const speedDisplay = document.getElementById('speed-meter');
        const loadingMsg = document.getElementById('loading-msg');

        async function initHandTracking() {
            const vision = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
            );
            
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numHands: 2 // Detect 2 hands for steering wheel
            });

            startWebcam();
        }

        function startWebcam() {
            navigator.mediaDevices.getUserMedia({ video: true }).then((stream) => {
                video.srcObject = stream;
                video.addEventListener("loadeddata", predictWebcam);
                loadingMsg.style.display = 'none';
                statusMsg.innerText = "Show BOTH hands to steer!";
            });
        }

        let lastVideoTime = -1;
        async function predictWebcam() {
            if (video.currentTime !== lastVideoTime) {
                lastVideoTime = video.currentTime;
                let startTimeMs = performance.now();
                if (handLandmarker) {
                    const result = handLandmarker.detectForVideo(video, startTimeMs);
                    processControls(result);
                }
            }
            requestAnimationFrame(predictWebcam);
        }

        // --- LOGIC: 2 HAND STEERING ---
        function processControls(result) {
            if (result.landmarks && result.landmarks.length === 2) {
                // We have 2 hands!
                const hand1 = result.landmarks[0][0]; // Wrist of hand 1
                const hand2 = result.landmarks[1][0]; // Wrist of hand 2
                
                // Identify Left and Right hand (Screen space x: 0 is left, 1 is right)
                // Note: Webcam is mirrored in CSS, but landmarks are original.
                // Let's just grab X coords.
                let leftHand, rightHand;
                if (hand1.x < hand2.x) {
                    leftHand = hand1; rightHand = hand2;
                } else {
                    leftHand = hand2; rightHand = hand1;
                }

                // 1. STEERING (Angle between wrists)
                // Y increases downwards in screen space.
                const dy = rightHand.y - leftHand.y;
                const dx = rightHand.x - leftHand.x;
                
                // Calculate angle. Sensitivity adjusted by factor 2
                const rawAngle = Math.atan2(dy, dx); 
                // Normally horizontal is 0. If right hand goes down (y increases), angle is positive.
                // We want: Right Hand Down = Turn Right.
                steeringAngle = -rawAngle * 2.5; 
                
                // Limit steering
                if (steeringAngle > 0.8) steeringAngle = 0.8;
                if (steeringAngle < -0.8) steeringAngle = -0.8;


                // 2. ACCELERATION (Check Index Fingers)
                // Check if index finger tip is significantly higher than index MCP (Knuckle)
                // Remember: Y is inverted (0 is top). So Tip < MCP means finger is UP.
                
                // Check Hand 1 Index
                const h1IndexTip = result.landmarks[0][8].y;
                const h1IndexMCP = result.landmarks[0][5].y;
                const h1IsPointing = h1IndexTip < h1IndexMCP - 0.05; // -0.05 threshold

                // Check Hand 2 Index
                const h2IndexTip = result.landmarks[1][8].y;
                const h2IndexMCP = result.landmarks[1][5].y;
                const h2IsPointing = h2IndexTip < h2IndexMCP - 0.05;

                if (h1IsPointing || h2IsPointing) {
                    // Accelerate
                    if (speed < maxSpeed) speed += 0.005;
                    statusMsg.innerText = "ðŸš€ GAS (Finger Up)";
                    statusMsg.style.color = "#00ff00";
                } else {
                    // Coast / Brake naturally (Fists closed)
                    if (speed > 0) speed -= 0.003;
                    statusMsg.innerText = "âœŠ COASTING (Steering)";
                    statusMsg.style.color = "#ffffff";
                }

                if (speed < 0) speed = 0;

            } else if (result.landmarks && result.landmarks.length === 1) {
                statusMsg.innerText = "âš ï¸ Need TWO Hands!";
                statusMsg.style.color = "yellow";
                // Slow down fast if hands lost
                speed *= 0.95; 
            } else {
                statusMsg.innerText = "ðŸ” No Hands Detected";
                speed *= 0.90;
            }
        }

        // --- GAME LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            // 1. Move Car
            // Apply steering rotation to the Car Container
            // Only turn if moving (Realism) - or slightly if stationary for visual
            if (Math.abs(speed) > 0.001) {
                carRotation += steeringAngle * speed * 0.15;
            }
            
            carContainer.rotation.y = carRotation;
            carContainer.translateZ(-speed); // Move forward relative to rotation

            // 2. Animate Wheels (Visual Only)
            // Front wheels turn left/right
            wheelFL.parentGroup.rotation.y = steeringAngle;
            wheelFR.parentGroup.rotation.y = steeringAngle;
            
            // All wheels spin based on speed
            const spinSpeed = speed * 5;
            wheelFL.rotation.x += spinSpeed;
            wheelFR.rotation.x += spinSpeed;
            wheelBL.rotation.x += spinSpeed;
            wheelBR.rotation.x += spinSpeed;

            // 3. Camera Follow (Third Person)
            // Calculate ideal camera position relative to car
            const offset = new THREE.Vector3(0, 4, 8); 
            offset.applyMatrix4(carContainer.matrixWorld);
            
            camera.position.lerp(offset, 0.1); // Smooth follow
            camera.lookAt(carContainer.position);

            // UI Update
            speedDisplay.innerText = Math.floor(speed * 300) + " km/h";

            renderer.render(scene, camera);
        }

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        initThreeJS();
        initHandTracking();
        animate();

    </script>
</body>
</html>
